# Kubernetesのコンポーネント

- 参照
    - [Kubernetesのコンポーネント](https://kubernetes.io/ja/docs/concepts/overview/components/)
    - [コンテナを使いこなすための心強い味方!「Kubernetes」(前編)](https://thinkit.co.jp/article/17453)


---

## コンテナオーケストレーションシステム「Kubernetes」 

2014年、Google社が自社サービスをコンテナ化しており、毎週20億のコンテナを起動していた」こと覚えているでしょうか。これほどまでのスケールになると、様々な問題が出てきます。

システムの運用管理、凄まじい数のコンテナをどのように作成・配置するのか、システムの可用性、スケーリングはどうしていくのか、状態監視をどうするか、などなど。
それらの煩雑なタスクやワークフローを自動化してくれるのが「オーケストレーションシステム」といわれる、いわばオーケストラの指揮者のような存在です。

コンテナマネジメントのデファクトスタンダードが「Kubernetes」である。

### Kubernatesを構成するクラスタとノード

ノードはアプリケーションを実行するマシン。 **ノード自体は一台の物理サーバもしくは仮想マシンと理解してください。**

ノードは、用途によってコンテナの実行ホストを提供する「ワーカーノード」(Worker Node)と、それを管理する「マスターノード」(Master Node)に分かれます。

Kubernetesでは、異なる役割を持つノードの「集まり」をクラスタという形で管理します。クラスタ内には少なくとも1つ以上のマスターノードと１つまたは複数のワーカーノードが存在します。

![image1](images_memo/image1.png)

クラスタを構成することで「**高可用性**」と「**負荷分散**」を実現できます。

- Kubernetesの高可用性

クラスタ内にあるコンテナなどのコンポーネントに障害が発生した場合、当該コンテナを自動で再起動させたり、他のノードでコンテナを起動させ、故障したコンテナが実行していた処理を引き継がせたりと、事前に定義した状態を維持します。

- Kubernetesの負荷分散

特定のノードに処理が集中しないように、ノード間で負荷を自動で分散します。これにより、クラスタ内のシステムリソースを効率よく運用できるようになります


## クラスタの構成要素

上記を実現するために、クラスタの構成要素は、以下のように各ノードに「コンポーネント」という形で配置されます。

![image2](images_memo/image2.png)

![image3](images_memo/image3.png)


## マスターノードとは？

マスターノードはクラスタ内にあるワーカーノードとPodを管理します。

Kubernetesには、クラスタ機能の提供に必要なものとしてコンポーネントと呼ばれるプロセスが実行されますが、その中でもマスターノードで実行されるコンポーネントを **マスターコンポーネント** と言います。

そして、マスターノードはクラスタ全体を管理するために、それぞれ役割を持った複数のマスターコンポーネント(ex. etcd, kube-schedulerなど)によって成り立っているのです。


- マスターコンポーネントの推奨配置 

マスターコンポーネントは、それぞれを別々のノードで起動させることもできますが、マスターコンポーネントだけを同じノードで全て実行させる方法が推奨されています。

マスターコンポーネントはそれぞれが密接に連携してクラスタを管理しており、バラバラに配置すると、あるマスターコンポーネントが実行されているノードに物理的な障害が発生した場合、連携が取れなくなりクラスタの管理機能が停止してしまう恐れがあります。

=> クラスタの稼動継続力(可用性)を高めたい場合は、マスターコンポーネントをそれぞれ1セットとして起動させたマスターノードを複数用意すると良し。


### マスターコンポーネント1：kube-api-server

**kube-api-serverを一言で言うと、「クラスタ内の全ての操作の窓口」になるマスターコンポーネント。**

外部からクラスタを操作する窓口となるAPI(アプリケーションプログラミングインタフェース)を公開しており、管理者はAPIを通じてKubernetesをコントロールする。

kube-api-serverを通してクラスタを操作する際に、ユーザ名や認証情報をリクエストと一緒に送る仕組みになっているのです。
そして、kube-api-serverはユーザ名や認証情報が正しいを照合する「認証」と、受信した操作リクエストが実行可能な権限を持つユーザによるものかを照合する「認可」の役割も備えています。

kube-api-serverの凄いところは認証認可に留まらず、リクエストの中身を確認して受け入れるかどうかを制御する「**入力制御**」の役割も担います。事前に指定した条件に沿わないリクエストはブロックしたり、リクエスト内容の一部の変更を行ったりするのです。

![image4](images_memo/image4.png)


- 補足

API」とは、「Application Programming Interface」

インターフェイスとは、コンピュータ用語でいうと、「何か」と「何か」をつなぐものという意味を持ちます。

APIは、「アプリケーション、ソフトウェア」と「プログラム」をつなぐもの。
APIとはソフトウェアやアプリケーションなどの一部を外部に向けて公開することにより、第三者が開発したソフトウェアと機能を共有できるようにしてくれるものです。

APIを公開する = **ソフトウェアにAPIという外部とやりとりする窓口を作り、外部アプリとコミュニケーションや連携ができる状態にする。**

参考：[今さら聞けないIT用語：やたらと耳にするけど「API」って何？](https://data.wingarc.com/what-is-api-16084)


### マスターコンポーネント2 : etcd

**etcdを一言で言うと、「クラスタ情報の保管庫」となるコンポーネント。**

**Kubernetesクラスタに関する全情報(ノードやPod、構成、アカウントやロールなど)** を保存します。

ノード情報を取得するリクエストが実行されたとき、表示される情報はkube-api-serverがetcdと直接やり取りをして引っ張ってきます。

Kubernetesは多数のノードをクラスタとして管理するため、ノード自体の障害やノード間を繋ぐネットワークに障害が起こってもシステムの継続稼動が求められます。これはetcdも同様です。
etcdは分散された多数のノード間でデータをレプリケート(複製)して保管することに適しており、マスターノードとマスターコンポーネントのセットが複数あっても一貫してクラスタ情報を保てる強みがある。

![image5](images_memo/image5.png)


### マスターコンポーネント3：kube-scheduler

**kube-schedulerは一言で言うと、「Podの配置決め」を行うコンポーネント。**

Podが新しく作成され、どのノードにも配置されなかった場合、schedulerがそれを検知して適切なノードに配置します。このとき、schedulerは、どのPodをどのノードに配置するか**のみ**を担当し、実際にPodを作成するわけではないことに注意。

- Podの配置の決め方

基本的にPodが各ノード間で偏りが出ないように配置します。

または、Podにリソース要件(CPUやメモリ量)などが設定されている場合は、要件を満たすノードを探して配置します。

- 配置決めの例

3つのノードと1つのPodがあるとします。Podはリソース要件として5CPUを設定しており、それぞれノードAは4CPU、ノードBは10CPU、ノードCは15CPUのリソースを持ちます。最初に、schedulerはPodの要件を満たさない4CPUのノードAを配置先候補から外します。次に、Podをノードに配置した際の空きリソース量が大きいノードを計算し、ノードCの方がノードBよりPod配置後の空きリソース量が最も多いため、最終的にノードCにPodを配置します。これらのステップをそれぞれ「**フィルタリング**」「**スコアリング**」と言う。様々な条件を指定可能。

![image6](images_memo/image6.png)


### マスターコンポーネント4：kube-controller-manager

**kube-controller-managerを一言で言うと、様々なコントローラをまとめて実行するコンポーネント。** (コントローラとは、Kubernetesのコンポーネントなどの状態を監視し、必要な対応を実行するプロセス)

- コントローラの例

ノードの状態を監視するノードコントローラは、kube-api-serverを通じて決められた間隔でノードのステータスを確認します。
もし、あるノードに問題が発生し、継続してステータス確認に失敗すると、そのノードに配置されているPodをscheduler経由で正常なノードに再割り当てします。ステータス確認に失敗したノードはschedulerの配置候補の対象から外されます。

コントローラは個別のプロセスですが、それらが1つの実行ファイルに纏められてcontroller-managerとして単一のプロセスで実行される。

![image7](images_memo/image7.png)


### マスターコンポーネント5：cloud-controller-manager

**cloud-controller-managerとは一言で言うと、kubernetesとパブリッククラウドを中継するコンポーネント。**

cloud-controller-managerは、Kubernetesで使用したいリソースと実際にクラウドで使用しているリソースを連携します。

例えば、パブリッククラウドの仮想マシンを利用してKubernetesを実装したとします。その際にクラウドのサービスで提供されているロードバランサーが必要になった場合、クラウド上で実際にロードバランサーを作成し、Kubernetesに関連付ける必要があります。

しかし、本来kubernetesにクラウドを操作する機能はありません。そこでcloud-controller-managerがKubernetesがやりたいことをパブリッククラウドとの間に入り操作の指示を中継することで、Kubernetes上の情報とパブリッククラウド上のリソースとの整合性を保ちます。 **kube-api-serverの代わりにクラウドとの第一窓口になってくれるわけです。**

![image8](images_memo/image8.png)


---

## ワーカーノードとは？

ワーカーノードは、実際にPodを動作させるためのノードです。

ワーカーノードは、Podとノードコンポーネントで成り立っており、マスターノードにより管理されます。


### ノードコンポーネント1：kubelet

**kubeletは、「エージェント」の役割を持つコンポーネント。**

各ノードで動作するKubernetesのエージェントで、Podの起動や管理を担います。

kube-schedulerからのPod配置指示をkube-api-server経由で受け取り、コンテナランタイムを操作してワーカーノード上にPodを作成します。そしてPodやノードの状態を監視してkubeapi-serverにレポートを送信します。

![image9](images_memo/image9.png)


### ノードコンポーネント2：kube-proxy

**kube-proxyとは、「ネットワーキングと負荷分散をサポート」するコンポーネント。**

各ノードで実行され、内部的にはLinuxカーネルのiptablesが利用されています。iptablesは主に通信の許可や遮断の機能と、受信した通信の送信先アドレスを変換し転送する機能などを持ちます。

kube-proxyはこれらを使って通信をPodへ転送するためのノード内のネットワークルールをメンテナンスします。

![image10](images_memo/image10.png)

また、kube-proxyはserviceの機能の一部を実装しています。serviceはクラスタIPという仮想的なIPで負荷分散をします。


### ノードコンポーネント3：コンテナランタイム

**コンテナランタイムとは、ワーカーノードでコンテナを実行するコンポーネント。**

**kubeletから受けた指示を元にコンテナのイメージ取得から実行までを行います。** 
コンテナランタイムは「高レベルランタイム」と「低レベルランタイム」の2層に分かれています。

- 高レベルランタイム

主にコンテナのイメージを取得し、実行するコンテナ環境の設定ファイルなどを作成する。

kubeletから **CRI(Container Runtime Interface)**　
というインターフェイスで呼び出されますが、CRIには高レベルランタイムで行うイメージ取得やコンテナ環境の設定などの定義情報が含まれています。

- 低レベルランタイム

設定ファイルを元に環境の作成やコンテナの実行を行います。

低レベルランタイムは **OCI(Open Container Initiative)** 
に準拠した仕様で高レベルランタイムから呼び出され、高レベルランタイムから受け取った情報を元にコンテナ環境を作成します。
OCIは低レベルランタイムの標準仕様で、設定ファイルを元に作られるNamespaceやcgroupなどの仕様が定められています。

![image11](images_memo/image11.png)
